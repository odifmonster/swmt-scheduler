from typing import TypeVar, Generic, Self, Any, Literal, Unpack, \
    Iterator, KeysView, ValuesView, ItemsView, Mapping, Set
from abc import ABC, abstractmethod
from app.support import Viewable, SupportsPrettyID

_T_Item = TypeVar('_T_Item', bound=Viewable)
_U_Item = TypeVar('_U_Item')

class Item(Generic[_T_Item, _U_Item]):
    """
    A class for storing data about the contents of Groups. Tracks insertion order for
    iteration and sorting purposes.
    """
    def __init__(self) -> None: ...
    @property
    def data(self) -> _U_Item:
        """Returns a view of this Item's contents (if non-empty)."""
        ...
    def __eq__(self, value: Self) -> bool: ...
    def __lt__(self, value: Self) -> bool: ...
    def was_inserted(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def insert(self, data: _T_Item, idx: int) -> None:
        """
        Call when inserting data into this Item. 'idx' argument should reflect the
        order of insertion in the container class.
        """
        ...
    def remove(self) -> _T_Item:
        """Empties this Item and returns the actual object it was holding."""
        ...

_S_BG_co = TypeVar('_S_BG_co', bound=Viewable[SupportsPrettyID], covariant=True)
_T_BG_co = TypeVar('_T_BG_co', bound=SupportsPrettyID, covariant=True)
_U_BG = TypeVar('_U_BG', str, int)

class BaseGroup(Generic[_S_BG_co, _T_BG_co, _U_BG], ABC, Mapping[Any, Any]):
    """
    An abstract mapping-like class whose lowest-level contents are read-only
    until they are removed. Contents are accessed by id, and insertion order is preserved
    at all levels.
    """
    def __init__(self, initsize: int, **kwargs: Unpack[dict[str, Any]]) -> None: ...
    @property
    def n_items(self) -> int:
        """
        The number of items in this Group. For sub-classes, differs from len(Group)
        in that "nested" groups will return the flat number of items, not the number
        of sub-groups.
        """
        ...
    @abstractmethod
    def __len__(self) -> int: ...
    @abstractmethod
    def __iter__(self) -> Iterator[Any]: ...
    @abstractmethod
    def __contains__(self, key: Any) -> Iterator[Any]: ...
    @abstractmethod
    def __getitem__(self, key: Any) -> Any: ...
    @abstractmethod
    def add(self, data: _S_BG_co) -> None: ...
    @abstractmethod
    def remove(self, item_id: _U_BG) -> _S_BG_co: ...
    @abstractmethod
    def keys(self) -> KeysView[Any]: ...
    @abstractmethod
    def values(self) -> ValuesView[Any]: ...
    @abstractmethod
    def items(self) -> ItemsView[Any]: ...
    def get_by_id(self, item_id: _U_BG) -> _T_BG_co: ...
    def iter_items(self) -> Iterator[_T_BG_co]: ...
    def props_match(self, data: _S_BG_co) -> bool:
        """
        Returns True iff the properties of \'data\' match all the values set in
        this group
        """
        ...
    def props_repr(self) -> str: ...

_S_A_co = TypeVar('_S_A_co', bound=Viewable[SupportsPrettyID], covariant=True)
_T_A_co = TypeVar('_T_A_co', bound=SupportsPrettyID, covariant=True)
_U_A = TypeVar('_U_A', str, int)

class AMapView(Generic[_S_A_co, _T_A_co, _U_A]):
    """
    Generic class for views on Atomic objects. Provides a __repr__ implementation.
    """
    def __init__(self,
                 link: BaseGroup[_S_A_co, _T_A_co, _U_A],
                 kind: Literal['keys', 'values', 'items']) -> None: ...
    def __repr__(self) -> str: ...

class AKeysView(Generic[_S_A_co, _T_A_co, _U_A],
                AMapView[_S_A_co, _T_A_co, _U_A],
                Set[_U_A]):
    """
    Generic class for key views on Atomic objects.
    """
    def __init__(self, link: BaseGroup[_S_A_co, _T_A_co, _U_A]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_U_A]: ...
    def __contains__(self, key: _U_A) -> bool: ...

class AValuesView(Generic[_S_A_co, _T_A_co, _U_A],
                  AMapView[_S_A_co, _T_A_co, _U_A],
                  Set[_T_A_co]):
    """
    Generic class for value views on Atomic objects.
    """
    def __init__(self, link: BaseGroup[_S_A_co, _T_A_co, _U_A]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T_A_co]: ...
    def __contains__(self, value: _T_A_co) -> bool: ...

class AItemsView(Generic[_S_A_co, _T_A_co, _U_A],
                  AMapView[_S_A_co, _T_A_co, _U_A],
                  Set[tuple[_U_A, _T_A_co]]):
    """
    Generic class for item views on Atomic objects.
    """
    def __init__(self, link: BaseGroup[_S_A_co, _T_A_co, _U_A]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[_U_A, _T_A_co]]: ...
    def __contains__(self, item: tuple[_U_A, _T_A_co]) -> bool: ...

class Atomic(Generic[_S_A_co, _T_A_co, _U_A],
             BaseGroup[_S_A_co, _T_A_co, _U_A]):
    """
    Generic class for "atomic" groups. Its keys are object ids, and its values
    are non-group objects.
    """
    def __init__(self, initsize: int = ..., **kwargs: Unpack[dict[str, Any]]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_U_A]: ...
    def __contains__(self, key: _U_A) -> bool: ...
    def __getitem__(self, key: _U_A) -> _T_A_co: ...
    def add(self, data: _S_A_co) -> None: ...
    def remove(self, item_id: _U_A) -> _S_A_co: ...
    def keys(self) -> AKeysView[_S_A_co, _T_A_co, _U_A]: ...
    def values(self) -> AValuesView[_S_A_co, _T_A_co, _U_A]: ...
    def items(self) -> AItemsView[_S_A_co, _T_A_co, _U_A]: ...